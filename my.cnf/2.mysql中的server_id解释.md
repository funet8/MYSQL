# mysql中的server_id解释


```
查看
show variables like '%server_id%';
```

## 一. server-id做什么用的

    1、 mysql的同步的数据中是包含server-id的，用于标识该语句最初是从哪个server写入的，所以server-id一定要有的
    2、 每一个同步中的slave在master上都对应一个master线程，该线程就是通过slave的server-id来标识的；每个slave在master端最多有一个master线程，如果两个slave的server-id 相同，则后一个连接成功时，前一个将被踢掉。 这里至少有这么一种考虑：
     slave主动连接master之后，如果slave上面执行了slave stop；则连接断开，但是master上对应的线程并没有退出；当slave start之后，master不能再创建一个线程而保留原来的线程，那样同步就可能有问题；
    3、 在mysql做主主同步时，多个主需要构成一个环状，但是同步的时候有要保证一条数据不会陷入死循环，这里就是靠server-id来实现的    

## 二.在my.cnf中设置服务器的ID是一个必要的步骤来实施或开始复制。 

一般的规则是，整个环境，我们正在实施MySQL复制服务器的ID必须是唯一的。

一般同时实施复制multi-master/circular，我们设置日志选项从更新的= 1。 所以任何声明时，将执行主的奴隶，它会被记录在该服务器的二进制日志。

例如，我们有3个服务器A，B和 C。 其服务器ID相应的11，22和33。 他们正在复制循环方式（多主），如A是主服务器B，B是C服务器和C的主人是一台服务器的主人。

现在任何MySQL客户端时，将执行插入/更新/删除服务器上的声明，它会被记录在二进制的服务器与服务器ID 11。

由于该语句记录在二进制的服务器，它会去到B服务器（因为B是奴隶），在那里执行和记录BINLOG B服务器在同一台服务器ID 11。 （为什么同一台服务器ID？因为本来这种说法，其执行由SQL线程不正规的mysql客户端发起的服务器与服务器ID 11和B服务器上）。

现在这个语句将再次进入到C服务器（因为C是B的奴隶），在那里执行的二进制日志中记录的C服务器在同一台服务器ID 11。

由于C是主服务器，该语句时会来的C服务器通过二进制日志的服务器， 一台服务器的 SQL线程将比较服务器ID，会发现，同11表示，这种说法是最初发起的服务器本身和没有必要执行SQL线程所以最后将跳过这一说法。

借助服务器的ID，我们就能避免死循环样的情况下在master-master/circular复制。

 
## 三.   my.cnf的配置
文件的[mysqld]部分包括一个log-bin选项。该部分还应有一个server-id=Master_id选项，其中master_id必须为1到232–1之间的一个正整数值。例如：

```
[mysqld]
log-bin=mysql-bin
server-id=1
```

如果没有提供那些选项，应添加它们并重启服务器。

9.    停止用于从服务器的服务器并在其my.cnf文件中添加下面的行：
```
[mysqld]
server-id=slave_id
```



slave_id值同Master_id值一样，必须为1到232–1之间的一个正整数值。并且，从服务器的ID必须与主服务器的ID不相同。例如：

[mysqld]
server-id=2
如果设置多个从服务器，每个从服务器必须有一个唯一的server-id值，必须与主服务器的以及其它从服务器的不相同。可以认为server-id值类似于IP地址：这些ID值能唯一识别复制服务器群集中的每个服务器实例。

如果不指定一个server-id值，如果没有定义master-host，则将它设置为1；否则设置为2。请注意如果server-id太长，主服务器 拒绝所有来自从服务器的连接，并且从服务器拒绝连接到主服务器。这样，省略server-id只适合用二进制日志备份。



